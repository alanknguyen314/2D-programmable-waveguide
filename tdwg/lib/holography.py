"""
This python module contains functions for holography.
"""
from tdwg.lib.ftutils_np import ft_f_axis, fft_centered, ifft_centered
import numpy as np
import matplotlib.pyplot as plt
from tdwg.lib.plot_utils import autoscale_y
import time

import astropy.units as u
from astropy.visualization import quantity_support
quantity_support()
u.set_enabled_equivalencies(u.dimensionless_angles())
import warnings

# When writing code and editting one of the libraries!
# from tdwg.lib.io_utils import *
# crazy_reload("tdwg.lib.ftutils_np", globals())
        

####### Constants for our setup ########
# The following constants are for the camera that we are using
resX = 630 
pixelpitch = 15*u.um #again for the camera that we are using!


#define a new class
class HolographicCamera():
    def __init__(self, linecam, calibration_dict):
        self.linecam = linecam
        self.load_calibration(calibration_dict)

    def load_calibration(self, calibration_dict):
        """
        Loads the calibration dictionary. 
        """
        cam_mag = calibration_dict["cam_mag"]        
        dx = pixelpitch/cam_mag
        fcenter = calibration_dict["fcenter"]
        fwidth = calibration_dict["fwidth"]
        xaxis_shift = calibration_dict["xaxis_shift"]
        # faxis_shift = calibration_dict["faxis_shift"]

        xaxis_cam = self.linecam.get_xaxis() - xaxis_shift
        faxis_raw = ft_f_axis(resX, dx).to(1/u.mm)

        xaxis_exp = get_xaxis_exp(xaxis_cam, faxis_raw, fcenter, fwidth)
        faxis_exp = get_faxis(xaxis_exp)# - faxis_shift

        #save all the variables in the class
        self.calibration_dict = calibration_dict
        self.dx = dx
        self.fcenter = fcenter
        self.fwidth = fwidth
        self.faxis_raw = faxis_raw
        self.xaxis_exp = xaxis_exp
        self.faxis_exp = faxis_exp

    def get_set_inds_mask(self, inds_shift=[-1, 0, 1]):
        """
        inds_shift corresponds to the number of pixels that we want to shift the mask by. 
        """
        ind_slab = self.linecam.find_ind_slab()
        inds_mask = []
        for ind in inds_shift:
            inds_mask.append(ind_slab + ind)
        self.inds_mask = inds_mask

    def measure_Eout_x(self):
        #collect data
        inds_mask = self.inds_mask
        faxis_raw = self.faxis_raw
        fcenter = self.fcenter
        fwidth = self.fwidth

        img_interf = self.linecam.get_image()

        output_interf = np.sum(img_interf[inds_mask, :].astype(np.float32), axis=0)
        Eout_x_exp = get_Eout_x(output_interf, faxis_raw, fcenter, fwidth)
        return Eout_x_exp

    def robust_measure_Eout_x(self, Nrepeat=3):
        Eout_x_exp_list = []
        for i in range(Nrepeat):
            Eout_x_exp = self.measure_Eout_x()
            Eout_x_exp_list.append(Eout_x_exp)
            time.sleep(0.1)

        power_list = [np.sum(abs(Eout_x_exp)**2) for Eout_x_exp in Eout_x_exp_list]
        ind_max = np.argmax(power_list)
        Eout_x_exp = Eout_x_exp_list[ind_max]
        return Eout_x_exp

    def safe_robust_measure_Eout_x(self, Nrepeat=3):
        """
        This version also looks for whether the warning for saturation of the camera has been triggered.
        Code partially generated by ChatGPT
        """
        with warnings.catch_warnings(record=True) as w:
            # Cause all warnings to always be triggered.
            warnings.simplefilter("always")
            Eout_x_exp = self.robust_measure_Eout_x(Nrepeat=Nrepeat)
            saturation_flag = (len(w) > 0)
        return Eout_x_exp, saturation_flag

    def check_inds_mask(self):
        linecam = self.linecam
        inds_mask = self.inds_mask

        img_interf = linecam.get_image()

        plt.figure(figsize=(12, 3))
        plt.imshow(img_interf, aspect="auto", cmap="hot")
        plt.ylim(inds_mask[0]-5, inds_mask[-1]+5)
        for ind in inds_mask:
            plt.axhline(ind, color="w", linestyle="--", alpha=0.5)
        plt.colorbar()


    def check_f_bounds(self, left_bound=None, right_bound=None):
        """
        To be frank, I should rarely need to check this...
        But yeah, it just checks the bounds. See the function that is not in the wrapper class for more details.
        """
        inds_mask = self.inds_mask

        img_interf = self.linecam.get_image()
        output_interf = np.sum(img_interf[inds_mask, :].astype(np.float32), axis=0)
        faxis_raw = self.faxis_raw
        fcenter = self.fcenter
        fwidth = self.fwidth

        check_f_bounds(output_interf, faxis_raw, fcenter, fwidth, left_bound, right_bound)

def check_f_bounds(output_interf, faxis_raw, fcenter=None, fwidth=None, left_bound=None, right_bound=None):
    """
    A utility function to figure out the center and width to use for off-axis digital holography. 

    Plots the fft to figure out if it is working as expected.
    """
    output_interf_f = fft_centered(output_interf)

    if fcenter is not None and fwidth is not None:
        fleft = fcenter - fwidth/2
        fright = fcenter + fwidth/2

    plt.figure(figsize=(7, 2))
    plt.plot(faxis_raw, np.abs(output_interf_f)**2, ".-")

    if left_bound is not None:
        plt.xlim(left=left_bound)

    if right_bound is not None:
        plt.xlim(right=right_bound)

    plt.xlabel(f"f ({faxis_raw.unit})")
    autoscale_y(plt.gca())

    if fwidth is not None:
        plt.axvline(fcenter, color='k', linestyle='--', alpha=0.5)
    if fwidth is not None:
        plt.axvline(fleft, color='red', linestyle='--')
        plt.axvline(fright, color='red', linestyle='--')

    plt.grid(alpha=0.5)

def get_Eout_x(output_interf, faxis_raw, fcenter, fwidth):
    """
    Returns faxis_exp and Eout_exp
    """
    #Get the basic processed inputs here
    output_interf_f = fft_centered(output_interf)
    fleft = fcenter - fwidth/2
    fright = fcenter + fwidth/2

    #Start cropping the relevant part of the data
    f2ind = lambda f: np.argmin(np.abs(faxis_raw - f))
    Eout_f_exp = output_interf_f[f2ind(fleft): f2ind(fright)]

    #Now reverse fft the data
    Eout_x_exp = ifft_centered(Eout_f_exp)
    return Eout_x_exp
    
def get_xaxis_exp(xaxis_cam, faxis_raw, fcenter, fwidth):
    f2ind = lambda f: np.argmin(np.abs(faxis_raw - f))
    fleft = fcenter - fwidth/2
    fright = fcenter + fwidth/2
    Nout = f2ind(fright) - f2ind(fleft)

    #this is the xaxis for the off-axis output! Saying off-axis might be best? Anyways, the notation is always hairy with these things... Probably exp is best to be consistent with the notation that was used previously for the analyzed Efield
    xaxis_exp = np.linspace(xaxis_cam[0], xaxis_cam[-1], Nout) 
    return xaxis_exp

def get_faxis(xaxis):
    dx = xaxis[1] - xaxis[0]
    Nout = len(xaxis)
    faxis = ft_f_axis(Nout, dx)
    return faxis

def get_phase(x, E, x_pt, unwrap_flag=True):
    phase = np.angle(E)
    if unwrap_flag:
        phase = np.unwrap(phase)
    ind = np.argmin(abs(x-x_pt))
    phase = phase - phase[ind]
    return phase


################## Spectogram code ##################
from tftb.processing import WignerVilleDistribution
from scipy.signal import spectrogram

def get_wigner(E):
    """
    You can use your regular x and f axis for this function. 

    Example, running it and plotting the output: 
    wigner_th = get_wigner(Eout_x_th)

    plt.figure(figsize=(6, 4))
    plt.pcolormesh((xaxis_th.to("mm")).value, (faxis_th.to("1/mm")/2).value, wigner_th, shading='auto', cmap="binary")
    plt.xlim(-0.600, 0.600)
    plt.ylim(-50, 50)
    plt.colorbar()
    plt.grid(alpha=0.2)
    plt.title("Wigner function")
    plt.xlabel("x (mm)")
    plt.ylabel("f (1/mm)")
    """
    wvd = WignerVilleDistribution(E)
    wigner, x_wig, f_wig = wvd.run()
    wigner = np.fft.fftshift(wigner, axes=0)
    return wigner

def get_spectrogram(Evec, xaxis_u, filter_size_u, nfft_factor=1):
    """
    Evec: vector of electric field
    xaxis_u: _u here denotes that it has units!
    filter_size_u =: This is the size of the filter
    nfft_factor: nfft in the code for the fourier transform is given by nfft_factor*len(Evec). Note that there is zero-padding, so this is important to get frequency resolution. Of course at some level, this is not super important as filter_size_u is setting the frequency resolution anyways.

    Note in the internals of the code, "_u" starts for unitful quantities, and "_val" denotes the value of the quantity in the unitless form. This is done for clarity in the code, I recommend to ditch this convention when used from the outside. 
    """

    #perform **everything** in the unit of xaxis_u!
    xaxis_val = xaxis_u.value
    xaxis_unit = xaxis_u.unit

    #convert the filter size to the same unit as xaxis_u
    filter_size_u = filter_size_u.to(xaxis_unit)
    filter_size_val = filter_size_u.value

    #enter the unitless function (can refractor out, but don't bother for now, since I am always going to use the unitful form most likely)
    fs = 1/(xaxis_val[1]-xaxis_val[0])

    nperseg = int(filter_size_val*fs)
    fspec_raw, xspec_raw, spec_raw = spectrogram(Evec, fs, nperseg=nperseg, noverlap=nperseg-1,
                        nfft=nfft_factor*len(Evec), detrend=False, return_onesided=False)

    spec = np.fft.fftshift(spec_raw, axes=0)
    fspec_val = np.fft.fftshift(fspec_raw)
    xspec_val = xspec_raw - (xspec_raw[-1]+xspec_raw[0])/2
    xspec_val += (xaxis_val[-1]+xaxis_val[0])/2

    #move the units back in
    fspec_unit = 1/xaxis_unit
    xspec_u = xspec_val * xaxis_unit
    fspec_u = fspec_val * fspec_unit
    return xspec_u, fspec_u, spec