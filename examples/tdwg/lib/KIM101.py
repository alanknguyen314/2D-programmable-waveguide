import clr
import time

import sys
sys.path.append(r"C:\Program Files\Thorlabs\Kinesis")

clr.AddReference("Thorlabs.MotionControl.DeviceManagerCLI")
clr.AddReference("Thorlabs.MotionControl.KCube.InertialMotorCLI")

from Thorlabs.MotionControl.DeviceManagerCLI import DeviceManagerCLI
from Thorlabs.MotionControl.KCube.InertialMotorCLI import KCubeInertialMotor, ThorlabsInertialMotorSettings, InertialMotorStatus

class KIM101():
    ''' 
    These actuators will generate noise at a typical level of 60 to 70 dB. The noise generated by a given piezo inertial motor
    is intrinsic to the "slip-stick" mechanism of the device, due to the short pulse widths required. Please review the green 
    box under the "Overview" tab at https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9776 for more information on the 
    mechanism of these devices.
    '''
    def __init__(self, serialNo=None, deviceType=""):
        DeviceManagerCLI.BuildDeviceList()
        serial_numbers = DeviceManagerCLI.GetDeviceList() # Could include prefix here (eg KCubeDCServo.DevicePrefix)
        # print("The devices with the following serial numbers are connected:", serial_numbers)

        if not serial_numbers:
            raise RuntimeError("Cannot connect, no devices found.")

        success = False
        for serialNo in serial_numbers if serialNo is None else [str(serialNo)]:
            try:
                self.instrument = KCubeInertialMotor.CreateKCubeInertialMotor(serialNo)
                self.instrument.Connect(serialNo)
                success = True
                break
            except:
                continue

        if success:
            print("Successfully connected to", serialNo)
        else:
            raise RuntimeError("Could not connect. Try restarting the motor. Serial #s found: " + " ".join(serial_numbers))

       
        try:
            self.instrument.WaitForSettingsInitialized(5000);
        except:
            Console.WriteLine("Settings failed to initialize");

        deviceInfo = self.instrument.GetDeviceInfo();
        print(f"Device {deviceInfo.SerialNumber} = {deviceInfo.Name}")

        # Start the device polling
        # The polling loop requests regular status requests to the motor to ensure the program keeps track of the device. 
        self.instrument.StartPolling(250);
        # Needs a delay so that the current enabled state can be obtained
        time.sleep(0.5);
        # Enable the channel otherwise any move is ignored 
        self.instrument.EnableDevice();
        # Needs a delay to give time for the device to be enabled
        time.sleep(0.5);

        # Call GetInertialMotorConfiguration on the device to initialize the settings
        InertialMotorConfiguration = self.instrument.GetInertialMotorConfiguration(serialNo);
        currentDeviceSettings = ThorlabsInertialMotorSettings.GetSettings(InertialMotorConfiguration);

        # Set the 'Step' paramaters for the Inertia Motor and download to device
        for i in range(4):
            currentDeviceSettings.Drive.Channel(i+1).StepRate = 500;
            currentDeviceSettings.Drive.Channel(i+1).StepAcceleration = 100000;
        self.instrument.SetSettings(currentDeviceSettings, True, True);
        
        
    def disconnect(self):
        self.instrument.StopPolling()
        self.instrument.Disconnect(True)
        
    def home(self):
        # Zero the device
        for i in range(4):
            pos = self.get_position(channel = i+1)
            if pos != 0:
                self.move_to(i+1, 0)
        
        print("Successfully homed")

    def move_to(self, 
             channel: InertialMotorStatus.MotorChannels, 
             position: int,
             wait_time: int = 10000):
        # The drive screw of these actuators typically rotates by ~ 0.4 mrad per step. 
        # Naturally, as is the case for the linear motion, this angular step can vary by about 20% and can be adjusted by 30% in both directions by KIM101.
        try:
            if self.get_position(channel) == position:
                print(f"Device is already at position {position}.")
            else:
                print(f"Moving channel {channel} to {position}")
                self.instrument.MoveTo(channel, position, wait_time)
        except:
            print("Failed to move to position")
            return
        
        print("Device Moved")
        
    def move_by(self, 
             channel: InertialMotorStatus.MotorChannels, 
             step_size: int,
             wait_time: int = 10000):
        # The drive screw of these actuators typically rotates by ~ 0.4 mrad per step. 
        # Naturally, as is the case for the linear motion, this angular step can vary by about 20% and can be adjusted by 30% in both directions by KIM101.
        try:
            if step_size != 0:
                print(f"Moving channel {channel} by {step_size}")
                self.instrument.MoveBy(channel, step_size, wait_time)
        except:
            print("Failed to move by step")
            return
        
    def get_position(self, channel: int):
        return self.instrument.GetPosition(channel);